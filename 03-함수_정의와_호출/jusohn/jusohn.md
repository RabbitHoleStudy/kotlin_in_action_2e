# 03장 - 함수 정의와 호출 (p.129 - p.170)

## 컬렉션

- 코틀린은 표준 자바 컬렉션 클래스를 사용함.
- 코틀린 컬렉션 인터페이스는 디폴트로 읽기 전용.

```kotlin
fun main() {
  val set = setOf(1, 7, 53)
  val list= listOf(1, 7, 53)
  val map = mapOf(1 to "one", 7 to "seven", 53 to "fifty-three")

  println(set.javaClass) // javaClass 는 자바 getClass() 에 해당하는 코틀린 표현이다.
  // class java.util.LinkedHashSet
  println(list.javaClass)
  // class java.util.Arrays$ArrayList
  println(map.javaClass)
  // class java.util.LinkedHashMap
}
```

- 코틀린으로 작성한 함수를 호출할 때는 함수에 전달하는 인자 중 일부 (혹은 전부) 의 이름을 명시할 수 있다. 전달하는 모든 인자의 이름을 지정하는 경우 심지어 인자 순서를 변경할 수도 있다．

- 기본 타입과 String 타입의 프로퍼티만 `const` 로 지정할 수 있다.

## 확장 함수

- 어떤 클래스의 멤버 메서드인 것처럼 호출할 수 있지만, 그 클래스의 밖에 선언된 함수.
- 확장 함수는 정적 메서드와 같은 특성을 가지므로 확장 함수를 하위 클래스에서 오버라이드할 수는 없음.
- 이름과 파라미터가 완전히 같은 확장 함수를 기반 클래스와 하위 클래스에 대해 정의할 수 있지만, 실제 호출될 함수는 확장 함수를 호출할 때 수신 객쳬로 지정한 변수의 컴파일 시점의 타입에 의해 결정됨.
  - 실행 시간에 그 변수에 저장된 객체의 타입에 의해 결정되지 않음.
- 어떤 클래스를 확장한 함수와 그 클래스의 멤버 함수의 이름과 시그니처가 같다면 확장 함수가 아니라 멤버 함수가 호출됨. (멤버 함수의 우선순위가 더 높음)
  - 클래스의 API를 확장할 경우 항상 이를 염두에 둬야 함.

## 확장 프로퍼티

- 확장 함수와 마찬가지로, 확장 프로퍼티를 사응하면 함수가 아니라 프로퍼티 형식의 구문으로 사용할 수 있는 API 를 추가할 수 있음.

## 쌍 (튜플) 다루기: 중위 호출과 구조 분해 선언

```kotlin
val map = mapOf(1 to "one", 7 to "seven", 53 to "fifty-three")
```

- `to` 는 코틀린 키워드가 아니라, **중위 호출** (infix call) 이라는 특별한 방식으로 `to` 라는 메서드를 호출한 것

```kotlin
1.to("one")
1 to "one"
// 위 두 호출은 동일함
```

## 요약

- 코틀린은 자쳬 컬렉 크 클래스를 정의하지 않지만 자바 클래스를 확장해서
  더 풍부한 API를 제공한다．
- 함수 파라미터의 기본값을 정의하면 오버로딩한 함수를 정의할 필요성이
  줄어든다.
  - 이름붙인 인자를 사용하면 함수의 인자가 많을 때 함수 호출의 가독성을 더 향상시킬 수 있다．
- 코틀린 파일에서 클래스 멤버가 아닌 최상위 함수와 프로퍼티를 직접 선언
  할 수 있다.
  - 이를 통해 코드 구조를 더 유연하게 만들 수 있다．
- 확장 함수와 프로퍼티를 사용하면 외부 라이브러리에 정의된 클래스를 포함해 모든 클래스의 API를 그 클래스의 소스코드를 바꿀 필요 없이 확장할 수 있다．
- 중위 호출을 통해 인자가 하나밖에 없는 메서드나 확장 함수를 더 깔끔한 구문으로 호출할 수 있다．
- 코틀린은 정규식과 일반 문자열을 처리할 때 유용한 다양한 문자열 처리 함수를 제공한다．
- 자바 문자열로 표현하려면 수많은 이스케이프가 필요한 문자열의 경우 3중 따옴표 문자열을 사용하면 더 깔끔하게 표현할 수 있다．
- 로컬 함수를 써서 코드를 더 깔끔하게 유지하면서 중복을 제거할 수 있다．

# 내 생각

- 복잡한데 되게 좋아 보인다 잘 쓰고싶다
