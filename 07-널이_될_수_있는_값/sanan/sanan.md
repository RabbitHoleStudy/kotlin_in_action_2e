- 요약
    - 코틀린은 널이 될 수 있는 타입을 지원해 `NullPointerException` 오류를 **컴파일 시점에 감지**할 수 있다.
    - 일반 타입들은 물음표를 붙여 명시적으로 널이 될 수 있는 타입이라고 지정하기 전까지, 기본적으로 널이 될 수 없다. 타입 이름 뒤의 ?는 널이 될 수 있음을 표시한다.
    - 코틀린은 널이 될 수 있는 타입을 간결하게 다룰 수 있는 다양한 도구를 제공한다.
    - *안전한 호출 연산자 (?.)**를 사용하면 널이 될 수 있는 객체의 메서드를 호출하거나 프로퍼티에 접근할 수 있다.
    - *엘비스 연산자 (?:)**를 사용하면 어떤 식이 null일 때 대신할 값을 지정할 수도 있고, 실행을 반환시키거나 예외를 던질 수도 있다.
    - *널 아님 단언 연산자 (!!)**는 컴파일러에게 주어진 값이 null이 아니라고 약속하는 것이다. (하지만 이 약속을 깨는 경우 책임은 개발자에게 있다.)
    - **let 영역 함수**는 자신이 호출된 수신 객체를 람다에게 전달한다. 안전한 호출 연산자와 함께 사용하면 널이 될 수 있는 타입을 널이 될 수 없는 타입으로 변환하는 효과가 있다.
    - **as? 연산자**를 사용하면 값을 다른 타입으로 변환하는 것과 변환이 불가능한 경우를 처리하는 것을 한꺼번에 편리하게 처리할 수 있다.
- nullable operator chaining을 통해서 정말 복잡할 수 있는 연산을 적당히 뭉쳐 놓을 수 있다.
- null-assertion(!!)는 컴파일러가 못알아먹을 때만 소리치는 용도로 쓰자.
    - 안 그러면 런타임에 어플리케이션이 죽어버릴지도?
- 용례(모니터)
- `lateinit var` 는 웬만해서 프레임워크 코드(DI 등)를 사용할 때 쓰자. 아무리 본인이 잘 관리할 수 있다고 하더라도 최대한 NPE를 확실하게 피하는 방법으로 코딩하는게 좋다는 생각. (물론 그 방법의 일환이긴 하지만)
- 자바-코틀린 상호운용은 마이그레이션이 아닌 이상 만질 일이 없을 것 같다는 생각이 문득 든다.

- 문제
    
    String?을 반환하는 findRandomString을 String을 반환하는 getRandomString으로 다음과 같은 방법을 사용해서 반환하라. 단, 기본 값은 `“ ”`이다.
    
    - 엘비스 연산자(`?:`)를 사용한 방법
    - null-safe `let`을 이용하는 방법
    
    ```kotlin
    fun findRandomString(): String? {
    	return listOf(UUID.randomUUID().toString(), null).random()
    }
    
    // 엘비스 연산자(?:)를 사용한 방법
    fun getRandomString(): String {
    	return findRandomString() ?: " "
    }
    
    // null-safe let을 이용하는 방법
    fun getRandomString(): String {
    	return findRandomString()?.let { it } ?: " "
    }
    // 엥? 이거 그냥 엘비스 연산자 쓰면 되는 거 아님? 이라고 생각할 수 있으나,
    // 실질적으로 어떠한 값을 취하고 해당 값에 대한 연산을 반환하되,
    // 그렇지 않은 경우에 대해 default를 두는 경우도 빈번히 있기 때문에 꽤 자주 사용 됨
    ```
